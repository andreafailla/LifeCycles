import math
import random
from collections import Counter, defaultdict

from statistics import mean, stdev

from lifecycles.classes import LifeCycle

def _generate_random_branch(R, size):
    elems = list()
    for subset in R:
        elems.extend(subset)
    return random.sample(elems, size)


def _null_test(branch, reference, num_permutations):
    null_branch = defaultdict(list)
    for _ in range(num_permutations):
        random_branch = _generate_random_branch(reference, len(branch))
        count = Counter(random_branch)
        for name, frequency in count.items():
            null_branch[name].append(frequency)

    avg_null_branch = defaultdict(dict)
    for name, frequencies in null_branch.items():
        avg_null_branch[name]['mean'] = mean(frequencies)
        avg_null_branch[name]['std'] = stdev(frequencies)
    return avg_null_branch


def _is_significant(name, subset, reference, num_permutations, significance_level=0.05):
    res = _null_test(subset, reference, num_permutations)
    z = (len(subset) - res[name]['mean']) / res[name]['std']
    p = 0.5 * math.erfc(abs(z) / math.sqrt(2))

    return p < significance_level


def validated_flow(lc: LifeCycle, target: str, direction: str, min_branch_size: int = 1,
                   num_permutations: int = 1000, significance_level: float = 0.05) -> dict:
    """
    Compare the flows with null model. Each branch of each flow is compared with a null model of the same size.
    The null model is generated by randomly sampling elements from the reference partition. The null model is
    generated num_permutations times. The mean and standard deviation of the null model are used to compute a z-score
    for each branch. The z-score is used to compute a p-value. If the p-value is less than the significance level,
    the branch is considered significant. The validated flow is the collection of significant branches.

    :param lc: a LifeCycle object
    :param target: target set identifier
    :param direction: temporal direction
    :param min_branch_size: minimum size of a branch to be considered
    :param num_permutations: number of permutations to be used to generate the null model
    :param significance_level: significance level
    :return: a dictionary keyed by set name and valued by the nodes in the validated flow
    """

    flow = lc.get_set_flow(target, direction, min_branch_size)
    tid = int(target.split('_')[0])
    if direction == '+':
        tid = tid + 1
    elif direction == '-':
        tid = tid - 1
    else:
        raise ValueError(f"Invalid direction: {direction}")
    reference = [[id_] * len(lc.get_set(id_)) for id_ in lc.get_partition_at(tid)]

    validated = dict()
    for name, subset in flow.items():
        if _is_significant(name, subset, reference, num_permutations, significance_level):
            validated[name] = subset
    return validated


def all_validated_flows(lc, direction, min_branch_size=1, num_permutations=1000, significance_level=0.05):
    """
    Compare all flows with null model. See validated_flow for details.

    :param lc: a LifeCycle object
    :param direction: temporal direction
    :param min_branch_size: minimum size of a branch to be considered
    :param num_permutations: number of permutations to be used to generate the null model
    :param significance_level: significance level
    :return: a dictionary keyed by set identifier and valued by the nodes in the validated flow
    """
    validated = dict()
    for target, flow in lc.all_flows(direction, min_branch_size).items():
        validated[target] = validated_flow(lc, target, direction, min_branch_size,
                                           num_permutations, significance_level)
    return validated
